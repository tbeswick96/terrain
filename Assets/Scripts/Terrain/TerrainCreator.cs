using System.Linq;
using UnityEngine;

namespace Assets.Scripts.Terrain {

    /*
     * Creates Unity terrain objects from the given world information.
     */
    public class TerrainCreator {

        //Creates and returns a Unity terrain object for the given tile indices based on the given world information.
        //The terrain object visible in the game scene is sized based on the heightmap size and a multiplier. Therefore the relationship between the worldpoints generated and the actual scene object is not 1:1.
        //This means extra calculations are required in order to corretly map the z values generated by the world generator to the heightmap values of the Unity terrain objects.
        public static GameObject CreateTerrain(World world, int i, int j) {
            TerrainData terrainData = new TerrainData() {
                heightmapResolution = Info.HEIGHTMAP_SIZE,
                alphamapResolution = Info.HEIGHTMAP_SIZE
            };
            terrainData.SetDetailResolution(Info.HEIGHTMAP_SIZE, 16);
            int offsetY = (Info.HEIGHTMAP_SIZE - 1) * j;
            int offsetX = (Info.HEIGHTMAP_SIZE - 1) * i;
            SetHeights(world, terrainData, offsetY, offsetX);
            SetTextures(world, terrainData, offsetY, offsetX);

            GameObject terrainObject = UnityEngine.Terrain.CreateTerrainGameObject(terrainData);
            terrainObject.name = "Terrain_" + i + "_" + j;
            terrainObject.transform.position = new Vector3(((i * (Info.HEIGHTMAP_SIZE - 1)) - Info.OFFSET) * Info.SIZE_MULTIPLIER, 0, ((j * (Info.HEIGHTMAP_SIZE - 1)) - Info.OFFSET) * Info.SIZE_MULTIPLIER);

            UnityEngine.Terrain terrain = terrainObject.GetComponent<UnityEngine.Terrain>();
            terrain.heightmapPixelError = 8;
            terrain.detailObjectDistance = 1000;
            terrain.materialType = UnityEngine.Terrain.MaterialType.Custom;
            terrain.materialTemplate = Info.MATERIAL;
            terrain.reflectionProbeUsage = UnityEngine.Rendering.ReflectionProbeUsage.Off;
            terrain.Flush();

            return terrainObject;
        }

        //Sets the heightmap heights for the given terrain object at the given offset, using the given world information.
        //The generated world information is an array with size [Heightmapsize * NumberOfTiles, Heightmapsize * NumberOfTiles].
        //This is split into a grid of tiles, each of which is a size of [Heightmapsize, Heightmapsize].
        //To map a point in the world information array to the correct point in a given tile, an offset is calculated. This offset is then added to the given position of the x,y coord of tile point.
        private static void SetHeights(World world, TerrainData terrainData, int offsetY, int offsetX) {
            float[,] heightMap = new float[terrainData.heightmapWidth, terrainData.heightmapWidth];
            //Info.log.Send(string.Format("Offset values for tile {0}_{1}[x:{2}, y:{3}]. Heightmap size: [x:{4}, y:{5}]", i, j, offsetX, offsetY, heightMap.GetLength(0), heightMap.GetLength(1)), 2);
            for (int y = 0; y < terrainData.heightmapWidth; y++) {
                for (int x = 0; x < terrainData.heightmapWidth; x++) {
                    heightMap[y, x] = world.worldMap[x + offsetX, y + offsetY].worldPoint.z;
                    //Info.log.Send(string.Format("Heightmap value for tile {0}_{1}[x:{2}, y:{3}] = {4}", i, j, x, y, heightMap[y, x]), 2);
                }
            }
            terrainData.SetHeights(0, 0, heightMap);
        }

        //Sets the textures of the Unity terrain object. This system uses what is called a splatmap, which is a set of layered textures. At each point in the splatmap, an alpha value is set.
        //Once in the world, this means multiple textures can be on the same point, based on the alpha values for each splatmap layer.
        //The alpha values are defined by several variables based on the information of the terrain point. This means texturing can be based on information like height value, steepness, etc.
        //For my implementation, I have 5 layers (and therefore 5 different textures), defined by the inverted steepness, the water amount (left over from hydraulic erosion), steepness, height (and sea level), and river state.
        //The alpha values for each layer are given in the range of 0 - 1.
        private static void SetTextures(World world, TerrainData terrainData, int offsetY, int offsetX) {
            terrainData.splatPrototypes = Info.TEXTURE_PROTOTYPES;
            terrainData.RefreshPrototypes();

            float[,,] splatMap = new float[terrainData.alphamapResolution, terrainData.alphamapResolution, terrainData.splatPrototypes.Length];
            for (int y = 0; y < terrainData.alphamapHeight; y++) {
                for (int x = 0; x < terrainData.alphamapWidth; x++) {
                    float normalizedY = (float) y / (terrainData.alphamapHeight - 1);
                    float normalizedX = (float) x / (terrainData.alphamapWidth - 1);
                    float height = terrainData.GetInterpolatedHeight(normalizedX, normalizedY);
                    float steepness = terrainData.GetSteepness(normalizedX, normalizedY);
                    float steepnessNormalized = Mathf.Clamp01(steepness * 2);

                    float[] splatWeights = new float[terrainData.alphamapLayers];
                    splatWeights[0] = height > 0.06f ? 1f - steepnessNormalized : 0f;
                    splatWeights[1] = 1f - ((world.worldMap[x + offsetX, y + offsetY].worldPoint.waterAmount) * 10);
                    splatWeights[2] = steepnessNormalized;
                    splatWeights[3] = height < 0.065f ? 1f : 0f;
                    splatWeights[4] = world.worldMap[x + offsetX, y + offsetY].worldPoint.isRiver ? 0.8f : 0f;
                    float weightSum = splatWeights.Sum();
                    for (int index = 0; index < terrainData.alphamapLayers; index++) {
                        splatWeights[index] /= weightSum;
                        splatMap[y, x, index] = splatWeights[index];
                    }
                }
            }
            terrainData.SetAlphamaps(0, 0, splatMap);
        }

        //Sets the detail layers for the Unity terrain. Like the splatmap above, layers are used to represent different types of detail.
        //This means different types of grass can be placed based on the information for that terrain point.
        //The values for each layer are given in the range of 0 - 16, which represents the density at each point.
        public static void SetDetail(World world, GameObject terrainObject, int i, int j) {
            int offsetY = (Info.HEIGHTMAP_SIZE - 1) * j;
            int offsetX = (Info.HEIGHTMAP_SIZE - 1) * i;
            TerrainData terrainData = terrainObject.GetComponent<UnityEngine.Terrain>().terrainData;
            terrainData.detailPrototypes = Info.DETAIL_PROTOTYPES;
            terrainData.RefreshPrototypes();

            int[,] details0 = new int[terrainData.detailWidth, terrainData.detailHeight];
            int[,] details1 = new int[terrainData.detailWidth, terrainData.detailHeight];
            int[,] details2 = new int[terrainData.detailWidth, terrainData.detailHeight];
            int[,] details3 = new int[terrainData.detailWidth, terrainData.detailHeight];
            for (int y = 0; y < terrainData.detailHeight; y++) {
                for (int x = 0; x < terrainData.detailWidth; x++) {
                    float normalizedY = (float) y / (terrainData.detailHeight - 1);
                    float normalizedX = (float) x / (terrainData.detailWidth - 1);
                    float height = terrainData.GetInterpolatedHeight(normalizedX, normalizedY);
                    float steepness = terrainData.GetSteepness(normalizedX, normalizedY);
                    float steepnessFactor = steepness < 0.5f ? 1f - Mathf.Clamp01(steepness) : 0f;
                    float heightFactor = height > 0.07f ? height : 0f;
                    float moistureFactor = 1f - ((world.worldMap[x + offsetX, y + offsetY].worldPoint.waterAmount) * 10);
                    details0[y, x] = System.Convert.ToInt32(world.worldMap[x + offsetX, y + offsetY].worldPoint.isRiver ? 0 : heightFactor * 16 * steepnessFactor * moistureFactor);
                    details1[y, x] = System.Convert.ToInt32(world.worldMap[x + offsetX, y + offsetY].worldPoint.isRiver ? 0 : heightFactor * 8 * steepnessFactor * moistureFactor);
                    details2[y, x] = System.Convert.ToInt32(world.worldMap[x + offsetX, y + offsetY].worldPoint.isRiver ? 0 : heightFactor * 8 * steepnessFactor * moistureFactor);
                    details3[y, x] = System.Convert.ToInt32(world.worldMap[x + offsetX, y + offsetY].worldPoint.isRiver ? 0 : heightFactor * 6 * (steepnessFactor / 2) * moistureFactor);
                }
            }            
            terrainData.SetDetailLayer(0, 0, 0, details0);
            terrainData.SetDetailLayer(0, 0, 1, details1);
            terrainData.SetDetailLayer(0, 0, 2, details2);
            terrainData.SetDetailLayer(0, 0, 3, details3);
            terrainData.size = new Vector3((Info.HEIGHTMAP_SIZE - 1) * Info.SIZE_MULTIPLIER, (Info.HEIGHTMAP_SIZE - 1) * Info.SIZE_MULTIPLIER, (Info.HEIGHTMAP_SIZE - 1) * Info.SIZE_MULTIPLIER);
        }

        //Sets the tree instances for the Unity terrain. A new tree instance is created for each tree.
        //This means different types of tree can be placed based on the information for that terrain point.
        public static void SetTrees(World world, GameObject terrainObject, int i, int j) {
            int offsetY = (Info.HEIGHTMAP_SIZE - 1) * j;
            int offsetX = (Info.HEIGHTMAP_SIZE - 1) * i;
            UnityEngine.Terrain terrain = terrainObject.GetComponent<UnityEngine.Terrain>();
            TerrainData terrainData = terrain.terrainData;
            terrainData.treePrototypes = Info.TREE_PROTOTYPES;
            terrainData.RefreshPrototypes();

            for (int y = 0; y < terrainData.heightmapHeight; y += 5) {
                for (int x = 0; x < terrainData.heightmapWidth; x += 5) {
                    float normalizedY = (float) y / (terrainData.heightmapHeight - 1);
                    float normalizedX = (float) x / (terrainData.heightmapWidth - 1);
                    float height = terrainData.GetInterpolatedHeight(normalizedX, normalizedY);
                    float heightChance = height > 40f ? 1f : 0f;
                    float steepness = terrainData.GetSteepness(normalizedX, normalizedY);
                    float steepnessChance = 1f - Mathf.Clamp01(steepness / 20);
                    float riverChance = world.worldMap[x + offsetX, y + offsetY].worldPoint.isRiver ? 0f : 1f;
                    if ((heightChance * riverChance * steepnessChance) > 0.1f && Info.RANDOM.Next(0, 20) > (Info.TILES + 4)) {
                        int index = Mathf.FloorToInt((height * 10) % 2);
                        float heightScale = index == 0 ? Info.RANDOM.Next(8, 10) / 10f : Info.RANDOM.Next(15, 20) / 10f;
                        terrain.AddTreeInstance(new TreeInstance() {
                            position = new Vector3(normalizedX, height, normalizedY),
                            prototypeIndex = index,
                            rotation = Info.RANDOM.Next(0, 10) / 10f,
                            heightScale = heightScale,
                            widthScale = heightScale,
                            color = new Color(0.5f, 0.5f, 0.5f),
                            lightmapColor = new Color(0.5f, 0.5f, 0.5f)
                        });
                    }
                }
            }
        }

        //Updates the neighbours for terrain object at the given tile indices.
        //Unity terrains can be seamless if the heightmap is correctly mapped, however the normals calculated by the Unity Engine must be updated in order for the terrain to be truly seamless.
        //If this step is skipped, terrains will have visible edges against each other.
        public static void UpdateNeighbours(GameObject[,] terrains, int i, int j) {
            UnityEngine.Terrain left = null, top = null, right = null, bottom = null;
            if (i - 1 >= 0) {
                left = terrains[i - 1, j].GetComponent<UnityEngine.Terrain>();
            }
            if (j + 1 < Info.TILES) {
                top = terrains[i, j + 1].GetComponent<UnityEngine.Terrain>();
            }
            if (i + 1 < Info.TILES) {
                right = terrains[i + 1, j].GetComponent<UnityEngine.Terrain>();
            }
            if (j - 1 >= 0) {
                bottom = terrains[i, j - 1].GetComponent<UnityEngine.Terrain>();
            }
            terrains[i, j].GetComponent<UnityEngine.Terrain>().SetNeighbors(left, top, right, bottom);
        }
    }
}